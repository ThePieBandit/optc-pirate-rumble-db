import { __decorate, __param, __read } from "tslib";
import { AfterViewInit, Directive, ElementRef, EventEmitter, Input, OnDestroy, Optional, Output, ViewContainerRef, HostListener, HostBinding, ChangeDetectorRef, } from '@angular/core';
import { isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';
import { Direction, Directionality } from '@angular/cdk/bidi';
import { Overlay, OverlayRef, OverlayConfig, HorizontalConnectionPos, VerticalConnectionPos, FlexibleConnectedPositionStrategy } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { throwMdePopoverMissingError } from './popover-errors';
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
var MdePopoverTrigger = /** @class */ (function () {
    function MdePopoverTrigger(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._dir = _dir;
        this._changeDetectorRef = _changeDetectorRef;
        this.ariaHaspopup = true;
        this._overlayRef = null;
        this._popoverOpen = false;
        this._halt = false;
        // tracking input type is necessary so it's possible to only auto-focus
        // the first item of the list when the popover is opened via the keyboard
        this._openedByMouse = false;
        /** Popover backdrop close on click */
        this.backdropCloseOnClick = true;
        /** Event emitted when the associated popover is opened. */
        this.opened = new EventEmitter();
        /** Event emitted when the associated popover is closed. */
        this.closed = new EventEmitter();
    }
    MdePopoverTrigger.prototype.ngAfterViewInit = function () {
        var _this = this;
        this._checkPopover();
        this._setCurrentConfig();
        this.popover.close.subscribe(function () { return _this.closePopover(); });
    };
    MdePopoverTrigger.prototype.ngOnDestroy = function () { this.destroyPopover(); };
    MdePopoverTrigger.prototype._setCurrentConfig = function () {
        if (this.positionX === 'before' || this.positionX === 'after') {
            this.popover.positionX = this.positionX;
        }
        if (this.positionY === 'above' || this.positionY === 'below') {
            this.popover.positionY = this.positionY;
        }
        if (this.triggerEvent) {
            this.popover.triggerEvent = this.triggerEvent;
        }
        if (this.enterDelay) {
            this.popover.enterDelay = this.enterDelay;
        }
        if (this.leaveDelay) {
            this.popover.leaveDelay = this.leaveDelay;
        }
        if (this.overlapTrigger === true || this.overlapTrigger === false) {
            this.popover.overlapTrigger = this.overlapTrigger;
        }
        if (this.targetOffsetX) {
            this.popover.targetOffsetX = this.targetOffsetX;
        }
        if (this.targetOffsetY) {
            this.popover.targetOffsetY = this.targetOffsetY;
        }
        if (this.arrowOffsetX) {
            this.popover.arrowOffsetX = this.arrowOffsetX;
        }
        if (this.arrowWidth) {
            this.popover.arrowWidth = this.arrowWidth;
        }
        if (this.arrowColor) {
            this.popover.arrowColor = this.arrowColor;
        }
        if (this.closeOnClick === true || this.closeOnClick === false) {
            this.popover.closeOnClick = this.closeOnClick;
        }
        this.popover.setCurrentStyles();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "popoverOpen", {
        /** Whether the popover is open. */
        get: function () { return this._popoverOpen; },
        enumerable: true,
        configurable: true
    });
    MdePopoverTrigger.prototype.onClick = function (event) {
        if (this.popover.triggerEvent === 'click') {
            // this.popover.setCurrentStyles();
            // this._setCurrentConfig();
            this.togglePopover();
        }
    };
    MdePopoverTrigger.prototype.onMouseEnter = function (event) {
        var _this = this;
        this._halt = false;
        if (this.popover.triggerEvent === 'hover') {
            this._mouseoverTimer = setTimeout(function () {
                _this.openPopover();
            }, this.popover.enterDelay);
        }
    };
    MdePopoverTrigger.prototype.onMouseLeave = function (event) {
        var _this = this;
        if (this.popover.triggerEvent === 'hover') {
            if (this._mouseoverTimer) {
                clearTimeout(this._mouseoverTimer);
                this._mouseoverTimer = null;
            }
            if (this._popoverOpen) {
                setTimeout(function () {
                    if (!_this.popover.closeDisabled) {
                        _this.closePopover();
                    }
                }, this.popover.leaveDelay);
            }
            else {
                this._halt = true;
            }
        }
    };
    /** Toggles the popover between the open and closed states. */
    MdePopoverTrigger.prototype.togglePopover = function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    MdePopoverTrigger.prototype.openPopover = function () {
        if (!this._popoverOpen && !this._halt) {
            this._createOverlay().attach(this._portal);
            /** Only subscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._subscribeToBackdrop();
            }
            this._initPopover();
        }
    };
    /** Closes the popover. */
    MdePopoverTrigger.prototype.closePopover = function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
            /** Only unsubscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._backdropSubscription.unsubscribe();
            }
            this._resetPopover();
        }
    };
    /** Removes the popover from the DOM. */
    MdePopoverTrigger.prototype.destroyPopover = function () {
        if (this._mouseoverTimer) {
            clearTimeout(this._mouseoverTimer);
            this._mouseoverTimer = null;
        }
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
            this._cleanUpSubscriptions();
        }
    };
    /** Focuses the popover trigger. */
    MdePopoverTrigger.prototype.focus = function () {
        this._elementRef.nativeElement.focus();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "dir", {
        /** The text direction of the containing app. */
        get: function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
    * This method ensures that the popover closes when the overlay backdrop is clicked.
    * We do not use first() here because doing so would not catch clicks from within
    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
    * explicitly when the popover is closed or destroyed.
    */
    MdePopoverTrigger.prototype._subscribeToBackdrop = function () {
        var _this = this;
        if (this._overlayRef) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                _this.popover._emitCloseEvent();
            });
        }
    };
    /**
    * This method sets the popover state to open and focuses the first item if
    * the popover was opened via the keyboard.
    */
    MdePopoverTrigger.prototype._initPopover = function () {
        this._setIsPopoverOpen(true);
    };
    /**
    * This method resets the popover when it's closed, most importantly restoring
    * focus to the popover trigger if the popover was opened via the keyboard.
    */
    MdePopoverTrigger.prototype._resetPopover = function () {
        this._setIsPopoverOpen(false);
        // Focus only needs to be reset to the host element if the popover was opened
        // by the keyboard and manually shifted to the first popover item.
        if (!this._openedByMouse) {
            this.focus();
        }
        this._openedByMouse = false;
    };
    /** set state rather than toggle to support triggers sharing a popover */
    MdePopoverTrigger.prototype._setIsPopoverOpen = function (isOpen) {
        this._popoverOpen = isOpen;
        this._popoverOpen ? this.opened.emit() : this.closed.emit();
    };
    /**
    *  This method checks that a valid instance of MdPopover has been passed into
    *  mdPopoverTriggerFor. If not, an exception is thrown.
    */
    MdePopoverTrigger.prototype._checkPopover = function () {
        if (!this.popover) {
            throwMdePopoverMissingError();
        }
    };
    /**
    *  This method creates the overlay from the provided popover's template and saves its
    *  OverlayRef so that it can be attached to the DOM when openPopover is called.
    */
    MdePopoverTrigger.prototype._createOverlay = function () {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);
            var config = this._getOverlayConfig();
            this._subscribeToPositions(config.positionStrategy);
            this._overlayRef = this._overlay.create(config);
        }
        return this._overlayRef;
    };
    /**
    * This method builds the configuration object needed to create the overlay, the OverlayConfig.
    * @returns OverlayConfig
    */
    MdePopoverTrigger.prototype._getOverlayConfig = function () {
        var overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getPosition();
        /** Display overlay backdrop if trigger event is click */
        if (this.triggerEvent === 'click') {
            overlayState.hasBackdrop = true;
            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
        }
        overlayState.direction = this.dir;
        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        return overlayState;
    };
    /**
    * Listens to changes in the position of the overlay and sets the correct classes
    * on the popover based on the new position. This ensures the animation origin is always
    * correct, even if a fallback position is used for the overlay.
    */
    MdePopoverTrigger.prototype._subscribeToPositions = function (position) {
        var _this = this;
        this._positionSubscription = position.positionChanges.subscribe(function (change) {
            var posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            var posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            if (!_this.popover.overlapTrigger) {
                posisionY = posisionY === 'below' ? 'above' : 'below';
            }
            // required for ChangeDetectionStrategy.OnPush
            _this._changeDetectorRef.markForCheck();
            _this.popover.zone.run(function () {
                _this.popover.positionX = posisionX;
                _this.popover.positionY = posisionY;
                _this.popover.setCurrentStyles();
                _this.popover.setPositionClasses(posisionX, posisionY);
            });
        });
    };
    /**
    * This method builds the position strategy for the overlay, so the popover is properly connected
    * to the trigger.
    * @returns ConnectedPositionStrategy
    */
    MdePopoverTrigger.prototype._getPosition = function () {
        var _a = __read(this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
        var _b = __read(this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
        // let originY = overlayY;
        // let fallbackOriginY = overlayFallbackY;
        var originY = overlayY;
        var originFallbackY = overlayFallbackY;
        var overlayX = originX;
        var overlayFallbackX = originFallbackX;
        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
        if (!this.popover.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        var offsetX = 0;
        var offsetY = 0;
        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
            offsetX = Number(this.popover.targetOffsetX);
            // offsetX = -16;
        }
        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
            offsetY = Number(this.popover.targetOffsetY);
            // offsetY = -10;
        }
        /**
         * For overriding position element, when mdePopoverTargetAt has a valid element reference.
         * Useful for sticking popover to parent element and offsetting arrow to trigger element.
         * If undefined defaults to the trigger element reference.
         */
        var element = this._elementRef;
        if (typeof this.targetElement !== 'undefined') {
            this.popover.containerPositioning = true;
            element = this.targetElement._elementRef;
        }
        return this._overlay.position()
            .flexibleConnectedTo(element)
            .withPositions([
            {
                originX: originX,
                originY: originY,
                overlayX: overlayX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originFallbackX,
                originY: originY,
                overlayX: overlayFallbackX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originX,
                originY: originFallbackY,
                overlayX: overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
        /*
        return this._overlay.position()
          .connectedTo(element,
              {originX: posX, originY: originY},
              {overlayX: posX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: originY},
              {overlayX: fallbackX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: posX, originY: fallbackOriginY},
              {overlayX: posX, overlayY: fallbackOverlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: fallbackOriginY},
              {overlayX: fallbackX, overlayY: fallbackOverlayY})
          .withOffsetX(offsetX)
          .withOffsetY(offsetY);
          */
    };
    MdePopoverTrigger.prototype._cleanUpSubscriptions = function () {
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
    };
    MdePopoverTrigger.prototype._handleMousedown = function (event) {
        if (event && !isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
        }
    };
    MdePopoverTrigger.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        HostBinding('attr.aria-haspopup')
    ], MdePopoverTrigger.prototype, "ariaHaspopup", void 0);
    __decorate([
        Input('mdePopoverTriggerFor')
    ], MdePopoverTrigger.prototype, "popover", void 0);
    __decorate([
        Input('mdePopoverTargetAt')
    ], MdePopoverTrigger.prototype, "targetElement", void 0);
    __decorate([
        Input('mdePopoverPositionX')
    ], MdePopoverTrigger.prototype, "positionX", void 0);
    __decorate([
        Input('mdePopoverPositionY')
    ], MdePopoverTrigger.prototype, "positionY", void 0);
    __decorate([
        Input('mdePopoverTriggerOn')
    ], MdePopoverTrigger.prototype, "triggerEvent", void 0);
    __decorate([
        Input('mdePopoverEnterDelay')
    ], MdePopoverTrigger.prototype, "enterDelay", void 0);
    __decorate([
        Input('mdePopoverLeaveDelay')
    ], MdePopoverTrigger.prototype, "leaveDelay", void 0);
    __decorate([
        Input('mdePopoverOverlapTrigger')
    ], MdePopoverTrigger.prototype, "overlapTrigger", void 0);
    __decorate([
        Input('mdePopoverOffsetX')
    ], MdePopoverTrigger.prototype, "targetOffsetX", void 0);
    __decorate([
        Input('mdePopoverOffsetY')
    ], MdePopoverTrigger.prototype, "targetOffsetY", void 0);
    __decorate([
        Input('mdePopoverArrowOffsetX')
    ], MdePopoverTrigger.prototype, "arrowOffsetX", void 0);
    __decorate([
        Input('mdePopoverArrowWidth')
    ], MdePopoverTrigger.prototype, "arrowWidth", void 0);
    __decorate([
        Input('mdePopoverArrowColor')
    ], MdePopoverTrigger.prototype, "arrowColor", void 0);
    __decorate([
        Input('mdePopoverCloseOnClick')
    ], MdePopoverTrigger.prototype, "closeOnClick", void 0);
    __decorate([
        Input('mdePopoverBackdropCloseOnClick')
    ], MdePopoverTrigger.prototype, "backdropCloseOnClick", void 0);
    __decorate([
        Output()
    ], MdePopoverTrigger.prototype, "opened", void 0);
    __decorate([
        Output()
    ], MdePopoverTrigger.prototype, "closed", void 0);
    __decorate([
        HostListener('click', ['$event'])
    ], MdePopoverTrigger.prototype, "onClick", null);
    __decorate([
        HostListener('mouseenter', ['$event'])
    ], MdePopoverTrigger.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave', ['$event'])
    ], MdePopoverTrigger.prototype, "onMouseLeave", null);
    __decorate([
        HostListener('mousedown', ['$event'])
    ], MdePopoverTrigger.prototype, "_handleMousedown", null);
    MdePopoverTrigger = __decorate([
        Directive({
            selector: '[mdePopoverTriggerFor]',
            exportAs: 'mdePopoverTrigger'
        }),
        __param(3, Optional())
    ], MdePopoverTrigger);
    return MdePopoverTrigger;
}());
export { MdePopoverTrigger };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS8iLCJzb3VyY2VzIjpbImxpYi9wb3BvdmVyL3BvcG92ZXItdHJpZ2dlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLGFBQWEsRUFDYixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULFFBQVEsRUFDUixNQUFNLEVBQ04sZ0JBQWdCLEVBQ2hCLFlBQVksRUFDWixXQUFXLEVBQ1gsaUJBQWlCLEdBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUQsT0FBTyxFQUNMLE9BQU8sRUFDUCxVQUFVLEVBQ1YsYUFBYSxFQUNiLHVCQUF1QixFQUN2QixxQkFBcUIsRUFDckIsaUNBQWlDLEVBQ2xDLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBTXJELE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBSS9EOzs7R0FHRztBQU1IO0lBeUVJLDJCQUFvQixRQUFpQixFQUFTLFdBQXVCLEVBQ25ELGlCQUFtQyxFQUN2QixJQUFvQixFQUNoQyxrQkFBcUM7UUFIbkMsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUFTLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ25ELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBa0I7UUFDdkIsU0FBSSxHQUFKLElBQUksQ0FBZ0I7UUFDaEMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQTFFcEIsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFHL0MsZ0JBQVcsR0FBc0IsSUFBSSxDQUFDO1FBQ3RDLGlCQUFZLEdBQUcs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OUIsS0FBSyxDQUFDLHNCQUFzQixDQUFDO3lEQUFvQjtJQUdmO1FBQWxDLEtBQUssQ0FBQywwQkFBMEIsQ0FBQzs2REFBeUI7SUFHL0I7UUFBM0IsS0FBSyxDQUFDLG1CQUFtQixDQUFDOzREQUF1QjtJQUd0QjtRQUEzQixLQUFLLENBQUMsbUJBQW1CLENBQUM7NERBQXVCO0lBR2pCO1FBQWhDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQzsyREFBc0I7SUFJdkI7UUFBOUIsS0FBSyxDQUFDLHNCQUFzQixDQUFDO3lEQUFvQjtJQUluQjtRQUE5QixLQUFLLENBQUMsc0JBQXNCLENBQUM7eURBQW9CO0lBSWpCO1FBQWhDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQzsyREFBdUI7SUFJZDtRQUF4QyxLQUFLLENBQUMsZ0NBQWdDLENBQUM7bUVBQTZCO0lBRzNEO1FBQVQsTUFBTSxFQUFFO3FEQUFtQztJQUdsQztRQUFULE1BQU0sRUFBRTtxREFBbUM7SUEwRVQ7UUFBbEMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29EQU1qQztJQUV1QztRQUF2QyxZQUFZLENBQUMsWUFBWSxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7eURBT3RDO0lBRXVDO1FBQXZDLFlBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzt5REFnQnRDO0lBZ1NzQztRQUF0QyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7NkRBSXJDO0lBcmRRLGlCQUFpQjtRQUo3QixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsd0JBQXdCO1lBQ2xDLFFBQVEsRUFBRSxtQkFBbUI7U0FDOUIsQ0FBQztRQTRFYSxXQUFBLFFBQVEsRUFBRSxDQUFBO09BM0VaLGlCQUFpQixDQXNkN0I7SUFBRCx3QkFBQztDQUFBLEFBdGRELElBc2RDO1NBdGRZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBEaXJlY3Rpb24sIERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHtcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheVJlZixcbiAgT3ZlcmxheUNvbmZpZyxcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gIFZlcnRpY2FsQ29ubmVjdGlvblBvcyxcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5cbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwsIE1kZVRhcmdldCB9IGZyb20gJy4vcG9wb3Zlci1pbnRlcmZhY2VzJztcbmltcG9ydCB7IE1kZVBvcG92ZXJQb3NpdGlvblgsIE1kZVBvcG92ZXJQb3NpdGlvblksIE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgfSBmcm9tICcuL3BvcG92ZXItdHlwZXMnO1xuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVyTWlzc2luZ0Vycm9yIH0gZnJvbSAnLi9wb3BvdmVyLWVycm9ycyc7XG5cblxuXG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhbiBtZGUtcG9wb3ZlciB0YWcuIEl0IGlzXG4gKiByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIHByb3ZpZGVkIHBvcG92ZXIgaW5zdGFuY2UuXG4gKi9cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW21kZVBvcG92ZXJUcmlnZ2VyRm9yXScsXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlclRyaWdnZXInXG59KVxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXJUcmlnZ2VyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkaXJlY3RpdmUtY2xhc3Mtc3VmZml4XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oYXNwb3B1cCcpIGFyaWFIYXNwb3B1cCA9IHRydWU7XG5cbiAgICBwcml2YXRlIF9wb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG4gICAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZiB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfaGFsdCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2JhY2tkcm9wU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIHByaXZhdGUgX21vdXNlb3ZlclRpbWVyOiBhbnk7XG5cbiAgICAvLyB0cmFja2luZyBpbnB1dCB0eXBlIGlzIG5lY2Vzc2FyeSBzbyBpdCdzIHBvc3NpYmxlIHRvIG9ubHkgYXV0by1mb2N1c1xuICAgIC8vIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBsaXN0IHdoZW4gdGhlIHBvcG92ZXIgaXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmRcbiAgICBwcml2YXRlIF9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XG5cbiAgICAvKiogUmVmZXJlbmNlcyB0aGUgcG9wb3ZlciBpbnN0YW5jZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyRm9yJykgcG9wb3ZlcjogTWRlUG9wb3ZlclBhbmVsO1xuXG4gICAgLyoqIFJlZmVyZW5jZXMgdGhlIHBvcG92ZXIgdGFyZ2V0IGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRhcmdldEF0JykgdGFyZ2V0RWxlbWVudDogTWRlVGFyZ2V0O1xuXG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBYIGF4aXMgKi9cbiAgICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblgnKSBwb3NpdGlvblg6IE1kZVBvcG92ZXJQb3NpdGlvblg7XG5cbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFkgYXhpcyAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWScpIHBvc2l0aW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWTtcblxuICAgIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKSB0cmlnZ2VyRXZlbnQ6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQ7XG5cbiAgICAvKiogUG9wb3ZlciBkZWxheSAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckVudGVyRGVsYXknKSBlbnRlckRlbGF5OiBudW1iZXI7XG5cbiAgICAvKiogUG9wb3ZlciBkZWxheSAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckxlYXZlRGVsYXknKSBsZWF2ZURlbGF5OiBudW1iZXI7XG5cbiAgICAvKiogUG9wb3ZlciBvdmVybGFwIHRyaWdnZXIgKi9cbiAgICBASW5wdXQoJ21kZVBvcG92ZXJPdmVybGFwVHJpZ2dlcicpIG92ZXJsYXBUcmlnZ2VyOiBib29sZWFuO1xuXG4gICAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB4ICovXG4gICAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WCcpIHRhcmdldE9mZnNldFg6IG51bWJlcjtcblxuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeSAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFknKSB0YXJnZXRPZmZzZXRZOiBudW1iZXI7XG5cbiAgICAvKiogUG9wb3ZlciBhcnJvdyBvZmZzZXQgeCAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93T2Zmc2V0WCcpIGFycm93T2Zmc2V0WDogbnVtYmVyO1xuXG5cbiAgICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93V2lkdGgnKSBhcnJvd1dpZHRoOiBudW1iZXI7XG5cblxuICAgIC8qKiBQb3BvdmVyIGFycm93IGNvbG9yICovXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dDb2xvcicpIGFycm93Q29sb3I6IHN0cmluZztcblxuXG4gICAgLyoqIFBvcG92ZXIgY29udGFpbmVyIGNsb3NlIG9uIGNsaWNrICovXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQ2xvc2VPbkNsaWNrJykgY2xvc2VPbkNsaWNrOiBib29sZWFuO1xuXG5cbiAgICAvKiogUG9wb3ZlciBiYWNrZHJvcCBjbG9zZSBvbiBjbGljayAqL1xuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckJhY2tkcm9wQ2xvc2VPbkNsaWNrJykgYmFja2Ryb3BDbG9zZU9uQ2xpY2sgPSB0cnVlO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBwb3BvdmVyIGlzIG9wZW5lZC4gKi9cbiAgICBAT3V0cHV0KCkgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgICAgICAgICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikgeyB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUG9wb3ZlcigpO1xuICAgICAgICB0aGlzLl9zZXRDdXJyZW50Q29uZmlnKCk7XG4gICAgICAgIHRoaXMucG9wb3Zlci5jbG9zZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZVBvcG92ZXIoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7IHRoaXMuZGVzdHJveVBvcG92ZXIoKTsgfVxuXG5cbiAgICBwcml2YXRlIF9zZXRDdXJyZW50Q29uZmlnKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgfHwgdGhpcy5wb3NpdGlvblggPT09ICdhZnRlcicpIHtcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID0gdGhpcy5wb3NpdGlvblg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblkgPT09ICdhYm92ZScgfHwgdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycpIHtcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID0gdGhpcy5wb3NpdGlvblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci50cmlnZ2VyRXZlbnQgPSB0aGlzLnRyaWdnZXJFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVudGVyRGVsYXkpIHtcbiAgICAgICAgICB0aGlzLnBvcG92ZXIuZW50ZXJEZWxheSA9IHRoaXMuZW50ZXJEZWxheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxlYXZlRGVsYXkpIHtcbiAgICAgICAgICB0aGlzLnBvcG92ZXIubGVhdmVEZWxheSA9IHRoaXMubGVhdmVEZWxheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXBUcmlnZ2VyID09PSB0cnVlIHx8IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIub3ZlcmxhcFRyaWdnZXIgPSB0aGlzLm92ZXJsYXBUcmlnZ2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0T2Zmc2V0WCkge1xuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFggPSB0aGlzLnRhcmdldE9mZnNldFg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50YXJnZXRPZmZzZXRZKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSA9IHRoaXMudGFyZ2V0T2Zmc2V0WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFycm93T2Zmc2V0WCkge1xuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmFycm93T2Zmc2V0WCA9IHRoaXMuYXJyb3dPZmZzZXRYO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmFycm93V2lkdGggPSB0aGlzLmFycm93V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcnJvd0NvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dDb2xvciA9IHRoaXMuYXJyb3dDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNsb3NlT25DbGljayA9PT0gdHJ1ZSB8fCB0aGlzLmNsb3NlT25DbGljayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5jbG9zZU9uQ2xpY2sgPSB0aGlzLmNsb3NlT25DbGljaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9wb3Zlci5zZXRDdXJyZW50U3R5bGVzKCk7XG4gICAgfVxuXG5cbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBvcGVuLiAqL1xuICAgIGdldCBwb3BvdmVyT3BlbigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuOyB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgLy8gdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAvLyB0aGlzLl9zZXRDdXJyZW50Q29uZmlnKCk7XG4gICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicsIFsnJGV2ZW50J10pIG9uTW91c2VFbnRlcihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgdGhpcy5faGFsdCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucG9wb3Zlci50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKCk7XG4gICAgICAgICAgfSwgdGhpcy5wb3BvdmVyLmVudGVyRGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBbJyRldmVudCddKSBvbk1vdXNlTGVhdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VzZW92ZXJUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX21vdXNlb3ZlclRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlb3ZlclRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcG9wb3Zlck9wZW4pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3BvdmVyLmNsb3NlRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLnBvcG92ZXIubGVhdmVEZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faGFsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVG9nZ2xlcyB0aGUgcG9wb3ZlciBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbiA/IHRoaXMuY2xvc2VQb3BvdmVyKCkgOiB0aGlzLm9wZW5Qb3BvdmVyKCk7XG4gICAgfVxuXG4gICAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xuICAgIG9wZW5Qb3BvdmVyKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuICYmICF0aGlzLl9oYWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCkuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG5cbiAgICAgICAgICAgIC8qKiBPbmx5IHN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXG4gICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycgJiYgdGhpcy5iYWNrZHJvcENsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2luaXRQb3BvdmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2xvc2VzIHRoZSBwb3BvdmVyLiAqL1xuICAgIGNsb3NlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuXG4gICAgICAgICAgLyoqIE9ubHkgdW5zdWJzY3JpYmUgdG8gYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xuICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJyAmJiB0aGlzLmJhY2tkcm9wQ2xvc2VPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3Jlc2V0UG9wb3ZlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJlbW92ZXMgdGhlIHBvcG92ZXIgZnJvbSB0aGUgRE9NLiAqL1xuICAgIGRlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fbW91c2VvdmVyVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9tb3VzZW92ZXJUaW1lcik7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jbGVhblVwU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEZvY3VzZXMgdGhlIHBvcG92ZXIgdHJpZ2dlci4gKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gICAgZ2V0IGRpcigpOiBEaXJlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSBwb3BvdmVyIGNsb3NlcyB3aGVuIHRoZSBvdmVybGF5IGJhY2tkcm9wIGlzIGNsaWNrZWQuXG4gICAgKiBXZSBkbyBub3QgdXNlIGZpcnN0KCkgaGVyZSBiZWNhdXNlIGRvaW5nIHNvIHdvdWxkIG5vdCBjYXRjaCBjbGlja3MgZnJvbSB3aXRoaW5cbiAgICAqIHRoZSBwb3BvdmVyLCBhbmQgaXQgd291bGQgZmFpbCB0byB1bnN1YnNjcmliZSBwcm9wZXJseS4gSW5zdGVhZCwgd2UgdW5zdWJzY3JpYmVcbiAgICAqIGV4cGxpY2l0bHkgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQgb3IgZGVzdHJveWVkLlxuICAgICovXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuX2VtaXRDbG9zZUV2ZW50KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIHBvcG92ZXIgc3RhdGUgdG8gb3BlbiBhbmQgZm9jdXNlcyB0aGUgZmlyc3QgaXRlbSBpZlxuICAgICogdGhlIHBvcG92ZXIgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICovXG4gICAgcHJpdmF0ZSBfaW5pdFBvcG92ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NldElzUG9wb3Zlck9wZW4odHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIHBvcG92ZXIgd2hlbiBpdCdzIGNsb3NlZCwgbW9zdCBpbXBvcnRhbnRseSByZXN0b3JpbmdcbiAgICAqIGZvY3VzIHRvIHRoZSBwb3BvdmVyIHRyaWdnZXIgaWYgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICovXG4gICAgcHJpdmF0ZSBfcmVzZXRQb3BvdmVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zZXRJc1BvcG92ZXJPcGVuKGZhbHNlKTtcblxuICAgICAgICAvLyBGb2N1cyBvbmx5IG5lZWRzIHRvIGJlIHJlc2V0IHRvIHRoZSBob3N0IGVsZW1lbnQgaWYgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZFxuICAgICAgICAvLyBieSB0aGUga2V5Ym9hcmQgYW5kIG1hbnVhbGx5IHNoaWZ0ZWQgdG8gdGhlIGZpcnN0IHBvcG92ZXIgaXRlbS5cbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRCeU1vdXNlKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogc2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBwb3BvdmVyICovXG4gICAgcHJpdmF0ZSBfc2V0SXNQb3BvdmVyT3Blbihpc09wZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9wb3Zlck9wZW4gPSBpc09wZW47XG4gICAgICAgIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5vcGVuZWQuZW1pdCgpIDogdGhpcy5jbG9zZWQuZW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGF0IGEgdmFsaWQgaW5zdGFuY2Ugb2YgTWRQb3BvdmVyIGhhcyBiZWVuIHBhc3NlZCBpbnRvXG4gICAgKiAgbWRQb3BvdmVyVHJpZ2dlckZvci4gSWYgbm90LCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICovXG4gICAgcHJpdmF0ZSBfY2hlY2tQb3BvdmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucG9wb3Zlcikge1xuICAgICAgICAgIHRocm93TWRlUG9wb3Zlck1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyB0aGUgb3ZlcmxheSBmcm9tIHRoZSBwcm92aWRlZCBwb3BvdmVyJ3MgdGVtcGxhdGUgYW5kIHNhdmVzIGl0c1xuICAgICogIE92ZXJsYXlSZWYgc28gdGhhdCBpdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB3aGVuIG9wZW5Qb3BvdmVyIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgIHRoaXMuX3BvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLnBvcG92ZXIudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2dldE92ZXJsYXlDb25maWcoKTtcbiAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1Bvc2l0aW9ucyhjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpO1xuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG5lZWRlZCB0byBjcmVhdGUgdGhlIG92ZXJsYXksIHRoZSBPdmVybGF5Q29uZmlnLlxuICAgICogQHJldHVybnMgT3ZlcmxheUNvbmZpZ1xuICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZygpOiBPdmVybGF5Q29uZmlnIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9nZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIC8qKiBEaXNwbGF5IG92ZXJsYXkgYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcbiAgICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICAgIG92ZXJsYXlTdGF0ZS5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LXRyYW5zcGFyZW50LWJhY2tkcm9wJztcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIExpc3RlbnMgdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Nlc1xuICAgICogb24gdGhlIHBvcG92ZXIgYmFzZWQgb24gdGhlIG5ldyBwb3NpdGlvbi4gVGhpcyBlbnN1cmVzIHRoZSBhbmltYXRpb24gb3JpZ2luIGlzIGFsd2F5c1xuICAgICogY29ycmVjdCwgZXZlbiBpZiBhIGZhbGxiYWNrIHBvc2l0aW9uIGlzIHVzZWQgZm9yIHRoZSBvdmVybGF5LlxuICAgICovXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Qb3NpdGlvbnMocG9zaXRpb246IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbiA9IHBvc2l0aW9uLnBvc2l0aW9uQ2hhbmdlcy5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2lzaW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWCA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCA9PT0gJ3N0YXJ0JyA/ICdhZnRlcicgOiAnYmVmb3JlJztcbiAgICAgICAgICAgIGxldCBwb3Npc2lvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVkgPT09ICd0b3AnID8gJ2JlbG93JyA6ICdhYm92ZSc7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgcG9zaXNpb25ZID0gcG9zaXNpb25ZID09PSAnYmVsb3cnID8gJ2Fib3ZlJyA6ICdiZWxvdyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIGZvciBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblggPSBwb3Npc2lvblg7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWSA9IHBvc2lzaW9uWTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnNldFBvc2l0aW9uQ2xhc3Nlcyhwb3Npc2lvblgsIHBvc2lzaW9uWSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IGZvciB0aGUgb3ZlcmxheSwgc28gdGhlIHBvcG92ZXIgaXMgcHJvcGVybHkgY29ubmVjdGVkXG4gICAgKiB0byB0aGUgdHJpZ2dlci5cbiAgICAqIEByZXR1cm5zIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3lcbiAgICAqL1xuICAgIHByaXZhdGUgX2dldFBvc2l0aW9uKCk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XG4gICAgICAgIGNvbnN0IFtvcmlnaW5YLCBvcmlnaW5GYWxsYmFja1hdOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvc1tdID1cbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID09PSAnYmVmb3JlJyA/IFsnZW5kJywgJ3N0YXJ0J10gOiBbJ3N0YXJ0JywgJ2VuZCddO1xuXG4gICAgICAgIGNvbnN0IFtvdmVybGF5WSwgb3ZlcmxheUZhbGxiYWNrWV06IFZlcnRpY2FsQ29ubmVjdGlvblBvc1tdID1cbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID09PSAnYWJvdmUnID8gWydib3R0b20nLCAndG9wJ10gOiBbJ3RvcCcsICdib3R0b20nXTtcblxuICAgICAgICAvLyBsZXQgb3JpZ2luWSA9IG92ZXJsYXlZO1xuICAgICAgICAvLyBsZXQgZmFsbGJhY2tPcmlnaW5ZID0gb3ZlcmxheUZhbGxiYWNrWTtcblxuICAgICAgICBsZXQgb3JpZ2luWSA9IG92ZXJsYXlZO1xuICAgICAgICBsZXQgb3JpZ2luRmFsbGJhY2tZID0gb3ZlcmxheUZhbGxiYWNrWTtcblxuICAgICAgICBjb25zdCBvdmVybGF5WCA9IG9yaWdpblg7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlGYWxsYmFja1ggPSBvcmlnaW5GYWxsYmFja1g7XG5cbiAgICAgICAgLy8gbGV0IFtvcmlnaW5ZLCBvcmlnaW5GYWxsYmFja1ldID0gW292ZXJsYXlZLCBvdmVybGF5RmFsbGJhY2tZXTtcbiAgICAgICAgLy8gbGV0IFtvdmVybGF5WCwgb3ZlcmxheUZhbGxiYWNrWF0gPSBbb3JpZ2luWCwgb3JpZ2luRmFsbGJhY2tYXTtcblxuICAgICAgICAvKiogUmV2ZXJzZSBvdmVybGF5WSBhbmQgZmFsbGJhY2tPdmVybGF5WSB3aGVuIG92ZXJsYXBUcmlnZ2VyIGlzIGZhbHNlICovXG4gICAgICAgIGlmICghdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgb3JpZ2luWSA9IG92ZXJsYXlZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgb3JpZ2luRmFsbGJhY2tZID0gb3ZlcmxheUZhbGxiYWNrWSA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldFggPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYICYmICFpc05hTihOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFgpKSkge1xuICAgICAgICAgIG9mZnNldFggPSBOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFgpO1xuICAgICAgICAgIC8vIG9mZnNldFggPSAtMTY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFkgJiYgIWlzTmFOKE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSkpKSB7XG4gICAgICAgICAgb2Zmc2V0WSA9IE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSk7XG4gICAgICAgICAgLy8gb2Zmc2V0WSA9IC0xMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igb3ZlcnJpZGluZyBwb3NpdGlvbiBlbGVtZW50LCB3aGVuIG1kZVBvcG92ZXJUYXJnZXRBdCBoYXMgYSB2YWxpZCBlbGVtZW50IHJlZmVyZW5jZS5cbiAgICAgICAgICogVXNlZnVsIGZvciBzdGlja2luZyBwb3BvdmVyIHRvIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXR0aW5nIGFycm93IHRvIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgICAgICogSWYgdW5kZWZpbmVkIGRlZmF1bHRzIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnQgcmVmZXJlbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5jb250YWluZXJQb3NpdGlvbmluZyA9IHRydWU7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy50YXJnZXRFbGVtZW50Ll9lbGVtZW50UmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhlbGVtZW50KVxuICAgICAgICAud2l0aFBvc2l0aW9ucyhbXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBvcmlnaW5YLFxuICAgICAgICAgICAgICBvcmlnaW5ZLFxuICAgICAgICAgICAgICBvdmVybGF5WCxcbiAgICAgICAgICAgICAgb3ZlcmxheVksXG4gICAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3JpZ2luWDogb3JpZ2luRmFsbGJhY2tYLFxuICAgICAgICAgICAgICBvcmlnaW5ZLFxuICAgICAgICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcbiAgICAgICAgICAgICAgb3ZlcmxheVksXG4gICAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiBvcmlnaW5GYWxsYmFja1ksXG4gICAgICAgICAgICBvdmVybGF5WCxcbiAgICAgICAgICAgIG92ZXJsYXlZOiBvdmVybGF5RmFsbGJhY2tZLFxuICAgICAgICAgICAgb2Zmc2V0WTogLW9mZnNldFlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbkZhbGxiYWNrWCxcbiAgICAgICAgICAgIG9yaWdpblk6IG9yaWdpbkZhbGxiYWNrWSxcbiAgICAgICAgICAgIG92ZXJsYXlYOiBvdmVybGF5RmFsbGJhY2tYLFxuICAgICAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXG4gICAgICAgICAgICBvZmZzZXRZOiAtb2Zmc2V0WVxuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WChvZmZzZXRYKVxuICAgICAgICAud2l0aERlZmF1bHRPZmZzZXRZKG9mZnNldFkpO1xuICAgICAgICAvKlxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAgICAgLmNvbm5lY3RlZFRvKGVsZW1lbnQsXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBvcmlnaW5ZfSxcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogb3ZlcmxheVl9KVxuICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgICAgICAgICAge29yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogb3JpZ2luWX0sXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogZmFsbGJhY2tYLCBvdmVybGF5WTogb3ZlcmxheVl9KVxuICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgICAgICAgICAge29yaWdpblg6IHBvc1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWX0sXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVl9KVxuICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgICAgICAgICAge29yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZfSxcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBmYWxsYmFja092ZXJsYXlZfSlcbiAgICAgICAgICAud2l0aE9mZnNldFgob2Zmc2V0WClcbiAgICAgICAgICAud2l0aE9mZnNldFkob2Zmc2V0WSk7XG4gICAgICAgICAgKi9cbiAgICB9XG5cbiAgICBwcml2YXRlIF9jbGVhblVwU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50J10pIF9oYW5kbGVNb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2ZW50ICYmICFpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkQnlNb3VzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=