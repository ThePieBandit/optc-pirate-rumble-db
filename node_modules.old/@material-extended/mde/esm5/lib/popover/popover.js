import { __decorate } from "tslib";
import { Component, EventEmitter, Input, OnDestroy, Output, TemplateRef, ViewChild, ViewEncapsulation, ElementRef, ChangeDetectionStrategy, HostBinding, NgZone } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { throwMdePopoverInvalidPositionX, throwMdePopoverInvalidPositionY } from './popover-errors';
import { transformPopover } from './popover-animations';
var MdePopover = /** @class */ (function () {
    function MdePopover(_elementRef, zone) {
        this._elementRef = _elementRef;
        this.zone = zone;
        this.role = 'dialog';
        /** Settings for popover, view setters and getters for more detail */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._disableAnimation = false;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        this._focusTrapAutoCaptureEnabled = true;
        /** Config object to be passed into the popover's ngClass */
        this._classList = {};
        // TODO: Write comment description
        /** */
        this.containerPositioning = false;
        /** Closing disabled on popover */
        this.closeDisabled = false;
        /** Emits the current animation state whenever it changes. */
        this._onAnimationStateChange = new EventEmitter();
        /** Event emitted when the popover is closed. */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    Object.defineProperty(MdePopover.prototype, "positionX", {
        /** Position of the popover in the X axis. */
        get: function () { return this._positionX; },
        set: function (value) {
            if (value !== 'before' && value !== 'after') {
                throwMdePopoverInvalidPositionX();
            }
            this._positionX = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "positionY", {
        /** Position of the popover in the Y axis. */
        get: function () { return this._positionY; },
        set: function (value) {
            if (value !== 'above' && value !== 'below') {
                throwMdePopoverInvalidPositionY();
            }
            this._positionY = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "triggerEvent", {
        /** Popover trigger event */
        get: function () { return this._triggerEvent; },
        set: function (value) { this._triggerEvent = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "enterDelay", {
        /** Popover enter delay */
        get: function () { return this._enterDelay; },
        set: function (value) { this._enterDelay = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "leaveDelay", {
        /** Popover leave delay */
        get: function () { return this._leaveDelay; },
        set: function (value) { this._leaveDelay = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "overlapTrigger", {
        /** Popover overlap trigger */
        get: function () { return this._overlapTrigger; },
        set: function (value) { this._overlapTrigger = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetX", {
        /** Popover target offset x */
        get: function () { return this._targetOffsetX; },
        set: function (value) { this._targetOffsetX = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetY", {
        /** Popover target offset y */
        get: function () { return this._targetOffsetY; },
        set: function (value) { this._targetOffsetY = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowOffsetX", {
        /** Popover arrow offset x */
        get: function () { return this._arrowOffsetX; },
        set: function (value) { this._arrowOffsetX = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowWidth", {
        /** Popover arrow width */
        get: function () { return this._arrowWidth; },
        set: function (value) { this._arrowWidth = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowColor", {
        /** Popover arrow color */
        get: function () { return this._arrowColor; },
        set: function (value) { this._arrowColor = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "closeOnClick", {
        /**
         * Popover container close on click
         * default: true
         */
        get: function () { return this._closeOnClick; },
        set: function (value) { this._closeOnClick = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "disableAnimation", {
        /**
         * Disable animations of popover and all child elements
         * default: false
         */
        get: function () { return this._disableAnimation; },
        set: function (value) { this._disableAnimation = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "focusTrapEnabled", {
        /**
         * Popover focus trap using cdkTrapFocus
         * default: true
         */
        get: function () { return this._focusTrapEnabled; },
        set: function (value) { this._focusTrapEnabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "focusTrapAutoCaptureEnabled", {
        /**
         * Popover focus trap auto capture using cdkTrapFocusAutoCapture
         * default: true
         */
        get: function () { return this._focusTrapAutoCaptureEnabled; },
        set: function (value) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "panelClass", {
        /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @param classes list of class names
         */
        set: function (classes) {
            if (classes && classes.length) {
                this._classList = classes.split(' ').reduce(function (obj, className) {
                    obj[className] = true;
                    return obj;
                }, {});
                this._elementRef.nativeElement.className = '';
                this.setPositionClasses();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "classList", {
        /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @deprecated Use `panelClass` instead.
         */
        get: function () { return this.panelClass; },
        set: function (classes) { this.panelClass = classes; },
        enumerable: true,
        configurable: true
    });
    MdePopover.prototype.ngOnDestroy = function () {
        this._emitCloseEvent();
        this.close.complete();
    };
    /** Handle a keyboard event from the popover, delegating to the appropriate action. */
    MdePopover.prototype._handleKeydown = function (event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    };
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     */
    MdePopover.prototype._emitCloseEvent = function () {
        this.close.emit();
    };
    /** Close popover on click if closeOnClick is true */
    MdePopover.prototype.onClick = function () {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    };
    /**
     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
     * https://github.com/angular/material2/pull/5493#issuecomment-313085323
     */
    /** Disables close of popover when leaving trigger element and mouse over the popover */
    MdePopover.prototype.onMouseOver = function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    };
    /** Enables close of popover when mouse leaving popover element */
    MdePopover.prototype.onMouseLeave = function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    };
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /** Sets the current styles for the popover to allow for dynamically changing settings */
    MdePopover.prototype.setCurrentStyles = function () {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    };
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     */
    MdePopover.prototype.setPositionClasses = function (posX, posY) {
        if (posX === void 0) { posX = this.positionX; }
        if (posY === void 0) { posY = this.positionY; }
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    };
    MdePopover.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    __decorate([
        HostBinding('attr.role')
    ], MdePopover.prototype, "role", void 0);
    __decorate([
        Input('mdePopoverPositionX')
    ], MdePopover.prototype, "positionX", null);
    __decorate([
        Input('mdePopoverPositionY')
    ], MdePopover.prototype, "positionY", null);
    __decorate([
        Input('mdePopoverTriggerOn')
    ], MdePopover.prototype, "triggerEvent", null);
    __decorate([
        Input('mdePopoverEnterDelay')
    ], MdePopover.prototype, "enterDelay", null);
    __decorate([
        Input('mdePopoverLeaveDelay')
    ], MdePopover.prototype, "leaveDelay", null);
    __decorate([
        Input('mdePopoverOverlapTrigger')
    ], MdePopover.prototype, "overlapTrigger", null);
    __decorate([
        Input('mdePopoverOffsetX')
    ], MdePopover.prototype, "targetOffsetX", null);
    __decorate([
        Input('mdePopoverOffsetY')
    ], MdePopover.prototype, "targetOffsetY", null);
    __decorate([
        Input('mdePopoverArrowOffsetX')
    ], MdePopover.prototype, "arrowOffsetX", null);
    __decorate([
        Input('mdePopoverArrowWidth')
    ], MdePopover.prototype, "arrowWidth", null);
    __decorate([
        Input('mdePopoverArrowColor')
    ], MdePopover.prototype, "arrowColor", null);
    __decorate([
        Input('mdePopoverCloseOnClick')
    ], MdePopover.prototype, "closeOnClick", null);
    __decorate([
        Input('mdePopoverDisableAnimation')
    ], MdePopover.prototype, "disableAnimation", null);
    __decorate([
        Input('mdeFocusTrapEnabled')
    ], MdePopover.prototype, "focusTrapEnabled", null);
    __decorate([
        Input('mdeFocusTrapAutoCaptureEnabled')
    ], MdePopover.prototype, "focusTrapAutoCaptureEnabled", null);
    __decorate([
        Input('class')
    ], MdePopover.prototype, "panelClass", null);
    __decorate([
        Input()
    ], MdePopover.prototype, "classList", null);
    __decorate([
        Output()
    ], MdePopover.prototype, "close", void 0);
    __decorate([
        ViewChild(TemplateRef)
    ], MdePopover.prototype, "templateRef", void 0);
    MdePopover = __decorate([
        Component({
            selector: 'mde-popover',
            template: "<ng-template>\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\" [@.disabled]=\"disableAnimation\"\n       [@transformPopover]=\"'enter'\">\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" [cdkTrapFocus]=\"focusTrapEnabled\" [cdkTrapFocusAutoCapture]=\"focusTrapAutoCaptureEnabled\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            animations: [
                transformPopover
            ],
            exportAs: 'mdePopover',
            styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"]
        })
    ], MdePopover);
    return MdePopover;
}());
export { MdePopover };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvIiwic291cmNlcyI6WyJsaWIvcG9wb3Zlci9wb3BvdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixXQUFXLEVBQ1gsU0FBUyxFQUNULGlCQUFpQixFQUNqQixVQUFVLEVBQ1YsdUJBQXVCLEVBQ3ZCLFdBQVcsRUFDWCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFJdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRy9DLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSwrQkFBK0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRXBHLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBYXhEO0lBaUxFLG9CQUFvQixXQUF1QixFQUFTLElBQVk7UUFBNUMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFRO1FBL0t0QyxTQUFJLEdBQUcsUUFBUSxDQUFDO1FBRTFDLHFFQUFxRTtRQUM3RCxlQUFVLEdBQXdCLE9BQU8sQ0FBQztRQUMxQyxlQUFVLEdBQXdCLE9BQU8sQ0FBQztRQUMxQyxrQkFBYSxHQUEyQixPQUFPLENBQUM7UUFDaEQsZ0JBQVcsR0FBRyxHQUFHLENBQUM7UUFDbEIsZ0JBQVcsR0FBRyxHQUFHLENBQUM7UUFDbEIsb0JBQWUsR0FBRyxJQUFJLENBQUM7UUFDdkIsc0JBQWlCLEdBQUcsS0FBSyxDQUFDO1FBQzFCLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLGtCQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ25CLGdCQUFXLEdBQUcs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SyxDQUFDLG1CQUFtQixDQUFDO21EQUNnQztJQUszRDtRQURDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQztrREFDeUI7SUFLekQ7UUFEQyxLQUFLLENBQUMsc0JBQXNCLENBQUM7Z0RBQ3VCO0lBS3JEO1FBREMsS0FBSyxDQUFDLHNCQUFzQixDQUFDO2dEQUN1QjtJQVFyRDtRQURDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQztrREFDMEI7SUFRMUQ7UUFEQyxLQUFLLENBQUMsNEJBQTRCLENBQUM7c0RBQzhCO0lBUWxFO1FBREMsS0FBSyxDQUFDLHFCQUFxQixDQUFDO3NEQUNxQztJQVFsRTtRQURDLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQztpRUFDZ0Q7SUFVeEY7UUFEQyxLQUFLLENBQUMsT0FBTyxDQUFDO2dEQVdkO0lBU0Q7UUFEQyxLQUFLLEVBQUU7K0NBQzJDO0lBSXpDO1FBQVQsTUFBTSxFQUFFOzZDQUFrQztJQUVuQjtRQUF2QixTQUFTLENBQUMsV0FBVyxDQUFDO21EQUErQjtJQS9LM0MsVUFBVTtRQVh0QixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsYUFBYTtZQUN2QiwrdUJBQTZCO1lBRTdCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1lBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO1lBQ3JDLFVBQVUsRUFBRTtnQkFDVixnQkFBZ0I7YUFDakI7WUFDRCxRQUFRLEVBQUUsWUFBWTs7U0FDdkIsQ0FBQztPQUNXLFVBQVUsQ0ErUXRCO0lBQUQsaUJBQUM7Q0FBQSxBQS9RRCxJQStRQztTQS9RWSxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIEVsZW1lbnRSZWYsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBIb3N0QmluZGluZyxcbiAgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcblxuaW1wb3J0IHsgTWRlUG9wb3ZlclBvc2l0aW9uWCwgTWRlUG9wb3ZlclBvc2l0aW9uWSwgTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB9IGZyb20gJy4vcG9wb3Zlci10eXBlcyc7XG5pbXBvcnQgeyB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25YLCB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25ZIH0gZnJvbSAnLi9wb3BvdmVyLWVycm9ycyc7XG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwgfSBmcm9tICcuL3BvcG92ZXItaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLWFuaW1hdGlvbnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZGUtcG9wb3ZlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9wb3BvdmVyLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9wb3BvdmVyLnNjc3MnXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmFuc2Zvcm1Qb3BvdmVyXG4gIF0sXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3Zlcidcbn0pXG5leHBvcnQgY2xhc3MgTWRlUG9wb3ZlciBpbXBsZW1lbnRzIE1kZVBvcG92ZXJQYW5lbCwgT25EZXN0cm95IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpjb21wb25lbnQtY2xhc3Mtc3VmZml4XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKSByb2xlID0gJ2RpYWxvZyc7XG5cbiAgLyoqIFNldHRpbmdzIGZvciBwb3BvdmVyLCB2aWV3IHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIG1vcmUgZGV0YWlsICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWCA9ICdhZnRlcic7XG4gIHByaXZhdGUgX3Bvc2l0aW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWSA9ICdiZWxvdyc7XG4gIHByaXZhdGUgX3RyaWdnZXJFdmVudDogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCA9ICdob3Zlcic7XG4gIHByaXZhdGUgX2VudGVyRGVsYXkgPSAyMDA7XG4gIHByaXZhdGUgX2xlYXZlRGVsYXkgPSAyMDA7XG4gIHByaXZhdGUgX292ZXJsYXBUcmlnZ2VyID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfZGlzYWJsZUFuaW1hdGlvbiA9IGZhbHNlO1xuICBwcml2YXRlIF90YXJnZXRPZmZzZXRYID0gMDtcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WSA9IDA7XG4gIHByaXZhdGUgX2Fycm93T2Zmc2V0WCA9IDIwO1xuICBwcml2YXRlIF9hcnJvd1dpZHRoID0gODtcbiAgcHJpdmF0ZSBfYXJyb3dDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJztcbiAgcHJpdmF0ZSBfY2xvc2VPbkNsaWNrID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfZm9jdXNUcmFwRW5hYmxlZCA9IHRydWU7XG4gIHByaXZhdGUgX2ZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZCA9IHRydWU7XG5cbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBuZ0NsYXNzICovXG4gIF9jbGFzc0xpc3Q6IHtba2V5OiBzdHJpbmddOiBib29sZWFufSA9IHt9O1xuXG4gIC8vIFRPRE86IFdyaXRlIGNvbW1lbnQgZGVzY3JpcHRpb25cbiAgLyoqICovXG4gIHB1YmxpYyBjb250YWluZXJQb3NpdGlvbmluZyA9IGZhbHNlO1xuXG4gIC8qKiBDbG9zaW5nIGRpc2FibGVkIG9uIHBvcG92ZXIgKi9cbiAgcHVibGljIGNsb3NlRGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGFycm93IG5nU3R5bGUgKi9cbiAgcHVibGljIHBvcG92ZXJQYW5lbFN0eWxlczoge307XG5cbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXG4gIHB1YmxpYyBwb3BvdmVyQXJyb3dTdHlsZXM6IHt9O1xuXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgY29udGVudCBuZ1N0eWxlICovXG4gIHB1YmxpYyBwb3BvdmVyQ29udGVudFN0eWxlczoge307XG5cbiAgLyoqIEVtaXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSB3aGVuZXZlciBpdCBjaGFuZ2VzLiAqL1xuICBfb25BbmltYXRpb25TdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8QW5pbWF0aW9uRXZlbnQ+KCk7XG5cblxuICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFggYXhpcy4gKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25YJylcbiAgZ2V0IHBvc2l0aW9uWCgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWDsgfVxuICBzZXQgcG9zaXRpb25YKHZhbHVlOiBNZGVQb3BvdmVyUG9zaXRpb25YKSB7XG4gICAgaWYgKHZhbHVlICE9PSAnYmVmb3JlJyAmJiB2YWx1ZSAhPT0gJ2FmdGVyJykge1xuICAgICAgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCgpO1xuICAgIH1cbiAgICB0aGlzLl9wb3NpdGlvblggPSB2YWx1ZTtcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICB9XG5cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBZIGF4aXMuICovXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWScpXG4gIGdldCBwb3NpdGlvblkoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvblk7IH1cbiAgc2V0IHBvc2l0aW9uWSh2YWx1ZTogTWRlUG9wb3ZlclBvc2l0aW9uWSkge1xuICAgIGlmICh2YWx1ZSAhPT0gJ2Fib3ZlJyAmJiB2YWx1ZSAhPT0gJ2JlbG93Jykge1xuICAgICAgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWSgpO1xuICAgIH1cbiAgICB0aGlzLl9wb3NpdGlvblkgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICB9XG5cbiAgLyoqIFBvcG92ZXIgdHJpZ2dlciBldmVudCAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKVxuICBnZXQgdHJpZ2dlckV2ZW50KCk6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgeyByZXR1cm4gdGhpcy5fdHJpZ2dlckV2ZW50OyB9XG4gIHNldCB0cmlnZ2VyRXZlbnQodmFsdWU6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQpIHsgdGhpcy5fdHJpZ2dlckV2ZW50ID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciBlbnRlciBkZWxheSAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJFbnRlckRlbGF5JylcbiAgZ2V0IGVudGVyRGVsYXkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2VudGVyRGVsYXk7IH1cbiAgc2V0IGVudGVyRGVsYXkodmFsdWU6IG51bWJlcikgeyB0aGlzLl9lbnRlckRlbGF5ID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciBsZWF2ZSBkZWxheSAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJMZWF2ZURlbGF5JylcbiAgZ2V0IGxlYXZlRGVsYXkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xlYXZlRGVsYXk7IH1cbiAgc2V0IGxlYXZlRGVsYXkodmFsdWU6IG51bWJlcikgeyB0aGlzLl9sZWF2ZURlbGF5ID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciBvdmVybGFwIHRyaWdnZXIgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyT3ZlcmxhcFRyaWdnZXInKVxuICBnZXQgb3ZlcmxhcFRyaWdnZXIoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9vdmVybGFwVHJpZ2dlcjsgfVxuICBzZXQgb3ZlcmxhcFRyaWdnZXIodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fb3ZlcmxhcFRyaWdnZXIgPSB2YWx1ZTsgfVxuXG4gIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeCAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRYJylcbiAgZ2V0IHRhcmdldE9mZnNldFgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3RhcmdldE9mZnNldFg7IH1cbiAgc2V0IHRhcmdldE9mZnNldFgodmFsdWU6IG51bWJlcikgeyB0aGlzLl90YXJnZXRPZmZzZXRYID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WScpXG4gIGdldCB0YXJnZXRPZmZzZXRZKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YXJnZXRPZmZzZXRZOyB9XG4gIHNldCB0YXJnZXRPZmZzZXRZKHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fdGFyZ2V0T2Zmc2V0WSA9IHZhbHVlOyB9XG5cbiAgLyoqIFBvcG92ZXIgYXJyb3cgb2Zmc2V0IHggKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dPZmZzZXRYJylcbiAgZ2V0IGFycm93T2Zmc2V0WCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fYXJyb3dPZmZzZXRYOyB9XG4gIHNldCBhcnJvd09mZnNldFgodmFsdWU6IG51bWJlcikgeyB0aGlzLl9hcnJvd09mZnNldFggPSB2YWx1ZTsgfVxuXG4gIC8qKiBQb3BvdmVyIGFycm93IHdpZHRoICovXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93V2lkdGgnKVxuICBnZXQgYXJyb3dXaWR0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fYXJyb3dXaWR0aDsgfVxuICBzZXQgYXJyb3dXaWR0aCh2YWx1ZTogbnVtYmVyKSB7IHRoaXMuX2Fycm93V2lkdGggPSB2YWx1ZTsgfVxuXG4gIC8qKiBQb3BvdmVyIGFycm93IGNvbG9yICovXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93Q29sb3InKVxuICBnZXQgYXJyb3dDb2xvcigpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fYXJyb3dDb2xvcjsgfVxuICBzZXQgYXJyb3dDb2xvcih2YWx1ZTogc3RyaW5nKSB7IHRoaXMuX2Fycm93Q29sb3IgPSB2YWx1ZTsgfVxuXG4gIC8qKlxuICAgKiBQb3BvdmVyIGNvbnRhaW5lciBjbG9zZSBvbiBjbGlja1xuICAgKiBkZWZhdWx0OiB0cnVlXG4gICAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJDbG9zZU9uQ2xpY2snKVxuICBnZXQgY2xvc2VPbkNsaWNrKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fY2xvc2VPbkNsaWNrOyB9XG4gIHNldCBjbG9zZU9uQ2xpY2sodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fY2xvc2VPbkNsaWNrID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGFuaW1hdGlvbnMgb2YgcG9wb3ZlciBhbmQgYWxsIGNoaWxkIGVsZW1lbnRzXG4gICAqIGRlZmF1bHQ6IGZhbHNlXG4gICAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJEaXNhYmxlQW5pbWF0aW9uJylcbiAgZ2V0IGRpc2FibGVBbmltYXRpb24oKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9kaXNhYmxlQW5pbWF0aW9uOyB9XG4gIHNldCBkaXNhYmxlQW5pbWF0aW9uKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2Rpc2FibGVBbmltYXRpb24gPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgLyoqXG4gICAqIFBvcG92ZXIgZm9jdXMgdHJhcCB1c2luZyBjZGtUcmFwRm9jdXNcbiAgICogZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgQElucHV0KCdtZGVGb2N1c1RyYXBFbmFibGVkJylcbiAgZ2V0IGZvY3VzVHJhcEVuYWJsZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9mb2N1c1RyYXBFbmFibGVkOyB9XG4gIHNldCBmb2N1c1RyYXBFbmFibGVkKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2ZvY3VzVHJhcEVuYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgLyoqXG4gICAqIFBvcG92ZXIgZm9jdXMgdHJhcCBhdXRvIGNhcHR1cmUgdXNpbmcgY2RrVHJhcEZvY3VzQXV0b0NhcHR1cmVcbiAgICogZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgQElucHV0KCdtZGVGb2N1c1RyYXBBdXRvQ2FwdHVyZUVuYWJsZWQnKVxuICBnZXQgZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkOyB9XG4gIHNldCBmb2N1c1RyYXBBdXRvQ2FwdHVyZUVuYWJsZWQodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1wb3BvdmVyIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcbiAgICogcG9wb3ZlciB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcbiAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGNsYXNzZXMgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgKi9cbiAgQElucHV0KCdjbGFzcycpXG4gIHNldCBwYW5lbENsYXNzKGNsYXNzZXM6IHN0cmluZykge1xuICAgIGlmIChjbGFzc2VzICYmIGNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc2VzLnNwbGl0KCcgJykucmVkdWNlKChvYmo6IGFueSwgY2xhc3NOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgb2JqW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSwge30pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1wb3BvdmVyIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcbiAgICogcG9wb3ZlciB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcbiAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBwYW5lbENsYXNzYCBpbnN0ZWFkLlxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IGNsYXNzTGlzdCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5wYW5lbENsYXNzOyB9XG4gIHNldCBjbGFzc0xpc3QoY2xhc3Nlczogc3RyaW5nKSB7IHRoaXMucGFuZWxDbGFzcyA9IGNsYXNzZXM7IH1cblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIGNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYpIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHB1YmxpYyB6b25lOiBOZ1pvbmUpIHtcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcbiAgICB0aGlzLmNsb3NlLmNvbXBsZXRlKCk7XG4gIH1cblxuXG4gIC8qKiBIYW5kbGUgYSBrZXlib2FyZCBldmVudCBmcm9tIHRoZSBwb3BvdmVyLCBkZWxlZ2F0aW5nIHRvIHRoZSBhcHByb3ByaWF0ZSBhY3Rpb24uICovXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcbiAgICogdHJpZ2dlciB3aWxsIGNsb3NlIHRoZSBwb3BvdmVyLlxuICAgKi9cbiAgX2VtaXRDbG9zZUV2ZW50KCk6IHZvaWQge1xuICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICB9XG5cbiAgLyoqIENsb3NlIHBvcG92ZXIgb24gY2xpY2sgaWYgY2xvc2VPbkNsaWNrIGlzIHRydWUgKi9cbiAgb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IFJlZmFjdG9yIHdoZW4gQGFuZ3VsYXIvY2RrIGluY2x1ZGVzIGZlYXR1cmUgSSBtZW50aW9uZWQgb24gZ2l0aHViIHNlZSBsaW5rIGJlbG93LlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9tYXRlcmlhbDIvcHVsbC81NDkzI2lzc3VlY29tbWVudC0zMTMwODUzMjNcbiAgICovXG4gIC8qKiBEaXNhYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbGVhdmluZyB0cmlnZ2VyIGVsZW1lbnQgYW5kIG1vdXNlIG92ZXIgdGhlIHBvcG92ZXIgKi9cbiAgb25Nb3VzZU92ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XG4gICAgICB0aGlzLmNsb3NlRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKiogRW5hYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbW91c2UgbGVhdmluZyBwb3BvdmVyIGVsZW1lbnQgKi9cbiAgb25Nb3VzZUxlYXZlKCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IFJlZmFjdG9yIGhvdyBzdHlsZXMgYXJlIHNldCBhbmQgdXBkYXRlZCBvbiB0aGUgY29tcG9uZW50LCB1c2UgYmVzdCBwcmFjdGljZXMuXG4gIC8vIFRPRE86IElmIGFycm93IGxlZnQgYW5kIHJpZ2h0IHBvc2l0aW9uaW5nIGlzIHJlcXVlc3RlZCwgc2VlIGlmIGZsZXggZGlyZWN0aW9uIGNhbiBiZSB1c2VkIHRvIHdvcmsgd2l0aCBvcmRlci5cbiAgLyoqIFNldHMgdGhlIGN1cnJlbnQgc3R5bGVzIGZvciB0aGUgcG9wb3ZlciB0byBhbGxvdyBmb3IgZHluYW1pY2FsbHkgY2hhbmdpbmcgc2V0dGluZ3MgKi9cbiAgc2V0Q3VycmVudFN0eWxlcygpIHtcblxuICAgIC8vIFRPRE86IFNlZSBpZiBhcnJvdyBwb3NpdGlvbiBjYW4gYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGFuZCBhbGxvdyBvdmVycmlkZS5cbiAgICAvLyBUT0RPOiBTZWUgaWYgZmxleCBvcmRlciBpcyBhIGJldHRlciBhbHRlcm5hdGl2ZSB0byBwb3NpdGlvbiBhcnJvdyB0b3Agb3IgYm90dG9tLlxuICAgIHRoaXMucG9wb3ZlckFycm93U3R5bGVzID0ge1xuICAgICAgJ3JpZ2h0JzogdGhpcy5wb3NpdGlvblggPT09ICdiZWZvcmUnID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcbiAgICAgICdsZWZ0JzogdGhpcy5wb3NpdGlvblggPT09ICdhZnRlcicgPyAodGhpcy5hcnJvd09mZnNldFggLSB0aGlzLmFycm93V2lkdGgpICsgJ3B4JyA6ICcnLFxuICAgICAgJ2JvcmRlci10b3AnOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2JlbG93JyA/XG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDogJzBweCBzb2xpZCB0cmFuc3BhcmVudCcsXG4gICAgICAnYm9yZGVyLXJpZ2h0JzogJ3VuZGVmaW5lZCcgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcbiAgICAgICdib3JkZXItYm90dG9tJzogdGhpcy5wb3NpdGlvblkgPT09ICdhYm92ZScgP1xuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXG4gICAgICAnYm9yZGVyLWxlZnQnOiAndW5kZWZpbmVkJyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxuICAgIH07XG5cbiAgICAvLyBUT0RPOiBSZW1vdmUgaWYgZmxleCBvcmRlciBpcyBhZGRlZC5cbiAgICB0aGlzLnBvcG92ZXJDb250ZW50U3R5bGVzID0ge1xuICAgICAgJ3BhZGRpbmctdG9wJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogdGhpcy5hcnJvd1dpZHRoICsgJ3B4JyxcbiAgICAgICdwYWRkaW5nLWJvdHRvbSc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgPyAnMHB4JyA6ICh0aGlzLmFycm93V2lkdGgpICsgJ3B4JyxcbiAgICAgICdtYXJnaW4tdG9wJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gZmFsc2UgJiYgdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycgJiYgdGhpcy5jb250YWluZXJQb3NpdGlvbmluZyA9PT0gZmFsc2UgP1xuICAgICAgICAtKHRoaXMuYXJyb3dXaWR0aCAqIDIpICsgJ3B4JyA6ICcwcHgnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCdzIG5lY2Vzc2FyeSB0byBzZXQgcG9zaXRpb24tYmFzZWQgY2xhc3NlcyB0byBlbnN1cmUgdGhlIHBvcG92ZXIgcGFuZWwgYW5pbWF0aW9uXG4gICAqIGZvbGRzIG91dCBmcm9tIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgICovXG4gIHNldFBvc2l0aW9uQ2xhc3Nlcyhwb3NYID0gdGhpcy5wb3NpdGlvblgsIHBvc1kgPSB0aGlzLnBvc2l0aW9uWSk6IHZvaWQge1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVmb3JlJ10gPSBwb3NYID09PSAnYmVmb3JlJztcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFmdGVyJ10gPSBwb3NYID09PSAnYWZ0ZXInO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYWJvdmUnXSA9IHBvc1kgPT09ICdhYm92ZSc7XG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1iZWxvdyddID0gcG9zWSA9PT0gJ2JlbG93JztcbiAgfVxufVxuIl19