import { __decorate } from "tslib";
import { Component, EventEmitter, Input, OnDestroy, Output, TemplateRef, ViewChild, ViewEncapsulation, ElementRef, ChangeDetectionStrategy, HostBinding, NgZone } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { throwMdePopoverInvalidPositionX, throwMdePopoverInvalidPositionY } from './popover-errors';
import { transformPopover } from './popover-animations';
let MdePopover = class MdePopover {
    constructor(_elementRef, zone) {
        this._elementRef = _elementRef;
        this.zone = zone;
        this.role = 'dialog';
        /** Settings for popover, view setters and getters for more detail */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._disableAnimation = false;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        this._focusTrapAutoCaptureEnabled = true;
        /** Config object to be passed into the popover's ngClass */
        this._classList = {};
        // TODO: Write comment description
        /** */
        this.containerPositioning = false;
        /** Closing disabled on popover */
        this.closeDisabled = false;
        /** Emits the current animation state whenever it changes. */
        this._onAnimationStateChange = new EventEmitter();
        /** Event emitted when the popover is closed. */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    /** Position of the popover in the X axis. */
    get positionX() { return this._positionX; }
    set positionX(value) {
        if (value !== 'before' && value !== 'after') {
            throwMdePopoverInvalidPositionX();
        }
        this._positionX = value;
        this.setPositionClasses();
    }
    /** Position of the popover in the Y axis. */
    get positionY() { return this._positionY; }
    set positionY(value) {
        if (value !== 'above' && value !== 'below') {
            throwMdePopoverInvalidPositionY();
        }
        this._positionY = value;
        this.setPositionClasses();
    }
    /** Popover trigger event */
    get triggerEvent() { return this._triggerEvent; }
    set triggerEvent(value) { this._triggerEvent = value; }
    /** Popover enter delay */
    get enterDelay() { return this._enterDelay; }
    set enterDelay(value) { this._enterDelay = value; }
    /** Popover leave delay */
    get leaveDelay() { return this._leaveDelay; }
    set leaveDelay(value) { this._leaveDelay = value; }
    /** Popover overlap trigger */
    get overlapTrigger() { return this._overlapTrigger; }
    set overlapTrigger(value) { this._overlapTrigger = value; }
    /** Popover target offset x */
    get targetOffsetX() { return this._targetOffsetX; }
    set targetOffsetX(value) { this._targetOffsetX = value; }
    /** Popover target offset y */
    get targetOffsetY() { return this._targetOffsetY; }
    set targetOffsetY(value) { this._targetOffsetY = value; }
    /** Popover arrow offset x */
    get arrowOffsetX() { return this._arrowOffsetX; }
    set arrowOffsetX(value) { this._arrowOffsetX = value; }
    /** Popover arrow width */
    get arrowWidth() { return this._arrowWidth; }
    set arrowWidth(value) { this._arrowWidth = value; }
    /** Popover arrow color */
    get arrowColor() { return this._arrowColor; }
    set arrowColor(value) { this._arrowColor = value; }
    /**
     * Popover container close on click
     * default: true
     */
    get closeOnClick() { return this._closeOnClick; }
    set closeOnClick(value) { this._closeOnClick = coerceBooleanProperty(value); }
    /**
     * Disable animations of popover and all child elements
     * default: false
     */
    get disableAnimation() { return this._disableAnimation; }
    set disableAnimation(value) { this._disableAnimation = coerceBooleanProperty(value); }
    /**
     * Popover focus trap using cdkTrapFocus
     * default: true
     */
    get focusTrapEnabled() { return this._focusTrapEnabled; }
    set focusTrapEnabled(value) { this._focusTrapEnabled = coerceBooleanProperty(value); }
    /**
     * Popover focus trap auto capture using cdkTrapFocusAutoCapture
     * default: true
     */
    get focusTrapAutoCaptureEnabled() { return this._focusTrapAutoCaptureEnabled; }
    set focusTrapAutoCaptureEnabled(value) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); }
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @param classes list of class names
     */
    set panelClass(classes) {
        if (classes && classes.length) {
            this._classList = classes.split(' ').reduce((obj, className) => {
                obj[className] = true;
                return obj;
            }, {});
            this._elementRef.nativeElement.className = '';
            this.setPositionClasses();
        }
    }
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @deprecated Use `panelClass` instead.
     */
    get classList() { return this.panelClass; }
    set classList(classes) { this.panelClass = classes; }
    ngOnDestroy() {
        this._emitCloseEvent();
        this.close.complete();
    }
    /** Handle a keyboard event from the popover, delegating to the appropriate action. */
    _handleKeydown(event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    }
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     */
    _emitCloseEvent() {
        this.close.emit();
    }
    /** Close popover on click if closeOnClick is true */
    onClick() {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    }
    /**
     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
     * https://github.com/angular/material2/pull/5493#issuecomment-313085323
     */
    /** Disables close of popover when leaving trigger element and mouse over the popover */
    onMouseOver() {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    }
    /** Enables close of popover when mouse leaving popover element */
    onMouseLeave() {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    }
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /** Sets the current styles for the popover to allow for dynamically changing settings */
    setCurrentStyles() {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    }
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     */
    setPositionClasses(posX = this.positionX, posY = this.positionY) {
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    }
};
MdePopover.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    HostBinding('attr.role')
], MdePopover.prototype, "role", void 0);
__decorate([
    Input('mdePopoverPositionX')
], MdePopover.prototype, "positionX", null);
__decorate([
    Input('mdePopoverPositionY')
], MdePopover.prototype, "positionY", null);
__decorate([
    Input('mdePopoverTriggerOn')
], MdePopover.prototype, "triggerEvent", null);
__decorate([
    Input('mdePopoverEnterDelay')
], MdePopover.prototype, "enterDelay", null);
__decorate([
    Input('mdePopoverLeaveDelay')
], MdePopover.prototype, "leaveDelay", null);
__decorate([
    Input('mdePopoverOverlapTrigger')
], MdePopover.prototype, "overlapTrigger", null);
__decorate([
    Input('mdePopoverOffsetX')
], MdePopover.prototype, "targetOffsetX", null);
__decorate([
    Input('mdePopoverOffsetY')
], MdePopover.prototype, "targetOffsetY", null);
__decorate([
    Input('mdePopoverArrowOffsetX')
], MdePopover.prototype, "arrowOffsetX", null);
__decorate([
    Input('mdePopoverArrowWidth')
], MdePopover.prototype, "arrowWidth", null);
__decorate([
    Input('mdePopoverArrowColor')
], MdePopover.prototype, "arrowColor", null);
__decorate([
    Input('mdePopoverCloseOnClick')
], MdePopover.prototype, "closeOnClick", null);
__decorate([
    Input('mdePopoverDisableAnimation')
], MdePopover.prototype, "disableAnimation", null);
__decorate([
    Input('mdeFocusTrapEnabled')
], MdePopover.prototype, "focusTrapEnabled", null);
__decorate([
    Input('mdeFocusTrapAutoCaptureEnabled')
], MdePopover.prototype, "focusTrapAutoCaptureEnabled", null);
__decorate([
    Input('class')
], MdePopover.prototype, "panelClass", null);
__decorate([
    Input()
], MdePopover.prototype, "classList", null);
__decorate([
    Output()
], MdePopover.prototype, "close", void 0);
__decorate([
    ViewChild(TemplateRef)
], MdePopover.prototype, "templateRef", void 0);
MdePopover = __decorate([
    Component({
        selector: 'mde-popover',
        template: "<ng-template>\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\" [@.disabled]=\"disableAnimation\"\n       [@transformPopover]=\"'enter'\">\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" [cdkTrapFocus]=\"focusTrapEnabled\" [cdkTrapFocusAutoCapture]=\"focusTrapAutoCaptureEnabled\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        encapsulation: ViewEncapsulation.None,
        animations: [
            transformPopover
        ],
        exportAs: 'mdePopover',
        styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"]
    })
], MdePopover);
export { MdePopover };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvIiwic291cmNlcyI6WyJsaWIvcG9wb3Zlci9wb3BvdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixXQUFXLEVBQ1gsU0FBUyxFQUNULGlCQUFpQixFQUNqQixVQUFVLEVBQ1YsdUJBQXVCLEVBQ3ZCLFdBQVcsRUFDWCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFJdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRy9DLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSwrQkFBK0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRXBHLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBYXhELElBQWEsVUFBVSxHQUF2QixNQUFhLFVBQVU7SUFpTHJCLFlBQW9CLFdBQXVCLEVBQVMsSUFBWTtRQUE1QyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7UUEvS3RDLFNBQUksR0FBRyxRQUFRLENBQUM7UUFFMUMscUVBQXFFO1FBQzdELGVBQVUsR0FBd0IsT0FBTyxDQUFDO1FBQzFDLGVBQVUsR0FBd0IsT0FBTyxDQUFDO1FBQzFDLGtCQUFhLEdBQTJCLE9BQU8sQ0FBQztRQUNoRCxnQkFBVyxHQUFHLEdBQUcsQ0FBQztRQUNsQixnQkFBVyxHQUFHLEdBQUcsQ0FBQztRQUNsQixvQkFBZSxHQUFHLElBQUksQ0FBQztRQUN2QixzQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFDMUIsbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFDbkIsbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFDbkIsa0JBQWEsR0FBRyxF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LEtBQUssQ0FBQyx3QkFBd0IsQ0FBQzs4Q0FDMEI7QUFRMUQ7SUFEQyxLQUFLLENBQUMsNEJBQTRCLENBQUM7a0RBQzhCO0FBUWxFO0lBREMsS0FBSyxDQUFDLHFCQUFxQixDQUFDO2tEQUNxQztBQVFsRTtJQURDLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQzs2REFDZ0Q7QUFVeEY7SUFEQyxLQUFLLENBQUMsT0FBTyxDQUFDOzRDQVdkO0FBU0Q7SUFEQyxLQUFLLEVBQUU7MkNBQzJDO0FBSXpDO0lBQVQsTUFBTSxFQUFFO3lDQUFrQztBQUVuQjtJQUF2QixTQUFTLENBQUMsV0FBVyxDQUFDOytDQUErQjtBQS9LM0MsVUFBVTtJQVh0QixTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsYUFBYTtRQUN2QiwrdUJBQTZCO1FBRTdCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1FBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO1FBQ3JDLFVBQVUsRUFBRTtZQUNWLGdCQUFnQjtTQUNqQjtRQUNELFFBQVEsRUFBRSxZQUFZOztLQUN2QixDQUFDO0dBQ1csVUFBVSxDQStRdEI7U0EvUVksVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBFbGVtZW50UmVmLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgSG9zdEJpbmRpbmcsXG4gIE5nWm9uZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5cbmltcG9ydCB7IE1kZVBvcG92ZXJQb3NpdGlvblgsIE1kZVBvcG92ZXJQb3NpdGlvblksIE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgfSBmcm9tICcuL3BvcG92ZXItdHlwZXMnO1xuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCwgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWSB9IGZyb20gJy4vcG9wb3Zlci1lcnJvcnMnO1xuaW1wb3J0IHsgTWRlUG9wb3ZlclBhbmVsIH0gZnJvbSAnLi9wb3BvdmVyLWludGVyZmFjZXMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlci1hbmltYXRpb25zJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWRlLXBvcG92ZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vcG9wb3Zlci5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vcG9wb3Zlci5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJhbnNmb3JtUG9wb3ZlclxuICBdLFxuICBleHBvcnRBczogJ21kZVBvcG92ZXInXG59KVxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXIgaW1wbGVtZW50cyBNZGVQb3BvdmVyUGFuZWwsIE9uRGVzdHJveSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJykgcm9sZSA9ICdkaWFsb2cnO1xuXG4gIC8qKiBTZXR0aW5ncyBmb3IgcG9wb3ZlciwgdmlldyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciBtb3JlIGRldGFpbCAqL1xuICBwcml2YXRlIF9wb3NpdGlvblg6IE1kZVBvcG92ZXJQb3NpdGlvblggPSAnYWZ0ZXInO1xuICBwcml2YXRlIF9wb3NpdGlvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSAnYmVsb3cnO1xuICBwcml2YXRlIF90cmlnZ2VyRXZlbnQ6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgPSAnaG92ZXInO1xuICBwcml2YXRlIF9lbnRlckRlbGF5ID0gMjAwO1xuICBwcml2YXRlIF9sZWF2ZURlbGF5ID0gMjAwO1xuICBwcml2YXRlIF9vdmVybGFwVHJpZ2dlciA9IHRydWU7XG4gIHByaXZhdGUgX2Rpc2FibGVBbmltYXRpb24gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WCA9IDA7XG4gIHByaXZhdGUgX3RhcmdldE9mZnNldFkgPSAwO1xuICBwcml2YXRlIF9hcnJvd09mZnNldFggPSAyMDtcbiAgcHJpdmF0ZSBfYXJyb3dXaWR0aCA9IDg7XG4gIHByaXZhdGUgX2Fycm93Q29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjEyKSc7XG4gIHByaXZhdGUgX2Nsb3NlT25DbGljayA9IHRydWU7XG4gIHByaXZhdGUgX2ZvY3VzVHJhcEVuYWJsZWQgPSB0cnVlO1xuICBwcml2YXRlIF9mb2N1c1RyYXBBdXRvQ2FwdHVyZUVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgbmdDbGFzcyAqL1xuICBfY2xhc3NMaXN0OiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcblxuICAvLyBUT0RPOiBXcml0ZSBjb21tZW50IGRlc2NyaXB0aW9uXG4gIC8qKiAqL1xuICBwdWJsaWMgY29udGFpbmVyUG9zaXRpb25pbmcgPSBmYWxzZTtcblxuICAvKiogQ2xvc2luZyBkaXNhYmxlZCBvbiBwb3BvdmVyICovXG4gIHB1YmxpYyBjbG9zZURpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXG4gIHB1YmxpYyBwb3BvdmVyUGFuZWxTdHlsZXM6IHt9O1xuXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgYXJyb3cgbmdTdHlsZSAqL1xuICBwdWJsaWMgcG9wb3ZlckFycm93U3R5bGVzOiB7fTtcblxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGNvbnRlbnQgbmdTdHlsZSAqL1xuICBwdWJsaWMgcG9wb3ZlckNvbnRlbnRTdHlsZXM6IHt9O1xuXG4gIC8qKiBFbWl0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgd2hlbmV2ZXIgaXQgY2hhbmdlcy4gKi9cbiAgX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEFuaW1hdGlvbkV2ZW50PigpO1xuXG5cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBYIGF4aXMuICovXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWCcpXG4gIGdldCBwb3NpdGlvblgoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvblg7IH1cbiAgc2V0IHBvc2l0aW9uWCh2YWx1ZTogTWRlUG9wb3ZlclBvc2l0aW9uWCkge1xuICAgIGlmICh2YWx1ZSAhPT0gJ2JlZm9yZScgJiYgdmFsdWUgIT09ICdhZnRlcicpIHtcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblgoKTtcbiAgICB9XG4gICAgdGhpcy5fcG9zaXRpb25YID0gdmFsdWU7XG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgfVxuXG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWSBheGlzLiAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblknKVxuICBnZXQgcG9zaXRpb25ZKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb25ZOyB9XG4gIHNldCBwb3NpdGlvblkodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblkpIHtcbiAgICBpZiAodmFsdWUgIT09ICdhYm92ZScgJiYgdmFsdWUgIT09ICdiZWxvdycpIHtcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkoKTtcbiAgICB9XG4gICAgdGhpcy5fcG9zaXRpb25ZID0gdmFsdWU7XG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgfVxuXG4gIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyVHJpZ2dlck9uJylcbiAgZ2V0IHRyaWdnZXJFdmVudCgpOiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IHsgcmV0dXJuIHRoaXMuX3RyaWdnZXJFdmVudDsgfVxuICBzZXQgdHJpZ2dlckV2ZW50KHZhbHVlOiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50KSB7IHRoaXMuX3RyaWdnZXJFdmVudCA9IHZhbHVlOyB9XG5cbiAgLyoqIFBvcG92ZXIgZW50ZXIgZGVsYXkgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyRW50ZXJEZWxheScpXG4gIGdldCBlbnRlckRlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9lbnRlckRlbGF5OyB9XG4gIHNldCBlbnRlckRlbGF5KHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fZW50ZXJEZWxheSA9IHZhbHVlOyB9XG5cbiAgLyoqIFBvcG92ZXIgbGVhdmUgZGVsYXkgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyTGVhdmVEZWxheScpXG4gIGdldCBsZWF2ZURlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sZWF2ZURlbGF5OyB9XG4gIHNldCBsZWF2ZURlbGF5KHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fbGVhdmVEZWxheSA9IHZhbHVlOyB9XG5cbiAgLyoqIFBvcG92ZXIgb3ZlcmxhcCB0cmlnZ2VyICovXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck92ZXJsYXBUcmlnZ2VyJylcbiAgZ2V0IG92ZXJsYXBUcmlnZ2VyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fb3ZlcmxhcFRyaWdnZXI7IH1cbiAgc2V0IG92ZXJsYXBUcmlnZ2VyKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX292ZXJsYXBUcmlnZ2VyID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHggKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WCcpXG4gIGdldCB0YXJnZXRPZmZzZXRYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YXJnZXRPZmZzZXRYOyB9XG4gIHNldCB0YXJnZXRPZmZzZXRYKHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fdGFyZ2V0T2Zmc2V0WCA9IHZhbHVlOyB9XG5cbiAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB5ICovXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFknKVxuICBnZXQgdGFyZ2V0T2Zmc2V0WSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0T2Zmc2V0WTsgfVxuICBzZXQgdGFyZ2V0T2Zmc2V0WSh2YWx1ZTogbnVtYmVyKSB7IHRoaXMuX3RhcmdldE9mZnNldFkgPSB2YWx1ZTsgfVxuXG4gIC8qKiBQb3BvdmVyIGFycm93IG9mZnNldCB4ICovXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93T2Zmc2V0WCcpXG4gIGdldCBhcnJvd09mZnNldFgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2Fycm93T2Zmc2V0WDsgfVxuICBzZXQgYXJyb3dPZmZzZXRYKHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fYXJyb3dPZmZzZXRYID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd1dpZHRoJylcbiAgZ2V0IGFycm93V2lkdGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2Fycm93V2lkdGg7IH1cbiAgc2V0IGFycm93V2lkdGgodmFsdWU6IG51bWJlcikgeyB0aGlzLl9hcnJvd1dpZHRoID0gdmFsdWU7IH1cblxuICAvKiogUG9wb3ZlciBhcnJvdyBjb2xvciAqL1xuICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd0NvbG9yJylcbiAgZ2V0IGFycm93Q29sb3IoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2Fycm93Q29sb3I7IH1cbiAgc2V0IGFycm93Q29sb3IodmFsdWU6IHN0cmluZykgeyB0aGlzLl9hcnJvd0NvbG9yID0gdmFsdWU7IH1cblxuICAvKipcbiAgICogUG9wb3ZlciBjb250YWluZXIgY2xvc2Ugb24gY2xpY2tcbiAgICogZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyQ2xvc2VPbkNsaWNrJylcbiAgZ2V0IGNsb3NlT25DbGljaygpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2Nsb3NlT25DbGljazsgfVxuICBzZXQgY2xvc2VPbkNsaWNrKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2Nsb3NlT25DbGljayA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICAvKipcbiAgICogRGlzYWJsZSBhbmltYXRpb25zIG9mIHBvcG92ZXIgYW5kIGFsbCBjaGlsZCBlbGVtZW50c1xuICAgKiBkZWZhdWx0OiBmYWxzZVxuICAgKi9cbiAgQElucHV0KCdtZGVQb3BvdmVyRGlzYWJsZUFuaW1hdGlvbicpXG4gIGdldCBkaXNhYmxlQW5pbWF0aW9uKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZGlzYWJsZUFuaW1hdGlvbjsgfVxuICBzZXQgZGlzYWJsZUFuaW1hdGlvbih2YWx1ZTogYm9vbGVhbikgeyB0aGlzLl9kaXNhYmxlQW5pbWF0aW9uID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIC8qKlxuICAgKiBQb3BvdmVyIGZvY3VzIHRyYXAgdXNpbmcgY2RrVHJhcEZvY3VzXG4gICAqIGRlZmF1bHQ6IHRydWVcbiAgICovXG4gIEBJbnB1dCgnbWRlRm9jdXNUcmFwRW5hYmxlZCcpXG4gIGdldCBmb2N1c1RyYXBFbmFibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZm9jdXNUcmFwRW5hYmxlZDsgfVxuICBzZXQgZm9jdXNUcmFwRW5hYmxlZCh2YWx1ZTogYm9vbGVhbikgeyB0aGlzLl9mb2N1c1RyYXBFbmFibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIC8qKlxuICAgKiBQb3BvdmVyIGZvY3VzIHRyYXAgYXV0byBjYXB0dXJlIHVzaW5nIGNka1RyYXBGb2N1c0F1dG9DYXB0dXJlXG4gICAqIGRlZmF1bHQ6IHRydWVcbiAgICovXG4gIEBJbnB1dCgnbWRlRm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkJylcbiAgZ2V0IGZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2ZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZDsgfVxuICBzZXQgZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2ZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtcG9wb3ZlciBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXG4gICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XG4gICAqIHRvIHN0eWxlIHRoZSBjb250YWluaW5nIHBvcG92ZXIgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjbGFzc2VzIGxpc3Qgb2YgY2xhc3MgbmFtZXNcbiAgICovXG4gIEBJbnB1dCgnY2xhc3MnKVxuICBzZXQgcGFuZWxDbGFzcyhjbGFzc2VzOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xhc3NlcyAmJiBjbGFzc2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3Nlcy5zcGxpdCgnICcpLnJlZHVjZSgob2JqOiBhbnksIGNsYXNzTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIG9ialtjbGFzc05hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtcG9wb3ZlciBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXG4gICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XG4gICAqIHRvIHN0eWxlIHRoZSBjb250YWluaW5nIHBvcG92ZXIgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcGFuZWxDbGFzc2AgaW5zdGVhZC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBjbGFzc0xpc3QoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMucGFuZWxDbGFzczsgfVxuICBzZXQgY2xhc3NMaXN0KGNsYXNzZXM6IHN0cmluZykgeyB0aGlzLnBhbmVsQ2xhc3MgPSBjbGFzc2VzOyB9XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gIEBPdXRwdXQoKSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwdWJsaWMgem9uZTogTmdab25lKSB7XG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XG4gICAgdGhpcy5jbG9zZS5jb21wbGV0ZSgpO1xuICB9XG5cblxuICAvKiogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgcG9wb3ZlciwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLiAqL1xuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgY2FzZSBFU0NBUEU6XG4gICAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBlbWl0cyBhIGNsb3NlIGV2ZW50IHRvIHdoaWNoIHRoZSB0cmlnZ2VyIGlzIHN1YnNjcmliZWQuIFdoZW4gZW1pdHRlZCwgdGhlXG4gICAqIHRyaWdnZXIgd2lsbCBjbG9zZSB0aGUgcG9wb3Zlci5cbiAgICovXG4gIF9lbWl0Q2xvc2VFdmVudCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgfVxuXG4gIC8qKiBDbG9zZSBwb3BvdmVyIG9uIGNsaWNrIGlmIGNsb3NlT25DbGljayBpcyB0cnVlICovXG4gIG9uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICB0aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBSZWZhY3RvciB3aGVuIEBhbmd1bGFyL2NkayBpbmNsdWRlcyBmZWF0dXJlIEkgbWVudGlvbmVkIG9uIGdpdGh1YiBzZWUgbGluayBiZWxvdy5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvbWF0ZXJpYWwyL3B1bGwvNTQ5MyNpc3N1ZWNvbW1lbnQtMzEzMDg1MzIzXG4gICAqL1xuICAvKiogRGlzYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIGxlYXZpbmcgdHJpZ2dlciBlbGVtZW50IGFuZCBtb3VzZSBvdmVyIHRoZSBwb3BvdmVyICovXG4gIG9uTW91c2VPdmVyKCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqIEVuYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIG1vdXNlIGxlYXZpbmcgcG9wb3ZlciBlbGVtZW50ICovXG4gIG9uTW91c2VMZWF2ZSgpIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcbiAgICAgIHRoaXMuY2xvc2VEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBSZWZhY3RvciBob3cgc3R5bGVzIGFyZSBzZXQgYW5kIHVwZGF0ZWQgb24gdGhlIGNvbXBvbmVudCwgdXNlIGJlc3QgcHJhY3RpY2VzLlxuICAvLyBUT0RPOiBJZiBhcnJvdyBsZWZ0IGFuZCByaWdodCBwb3NpdGlvbmluZyBpcyByZXF1ZXN0ZWQsIHNlZSBpZiBmbGV4IGRpcmVjdGlvbiBjYW4gYmUgdXNlZCB0byB3b3JrIHdpdGggb3JkZXIuXG4gIC8qKiBTZXRzIHRoZSBjdXJyZW50IHN0eWxlcyBmb3IgdGhlIHBvcG92ZXIgdG8gYWxsb3cgZm9yIGR5bmFtaWNhbGx5IGNoYW5naW5nIHNldHRpbmdzICovXG4gIHNldEN1cnJlbnRTdHlsZXMoKSB7XG5cbiAgICAvLyBUT0RPOiBTZWUgaWYgYXJyb3cgcG9zaXRpb24gY2FuIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBhbmQgYWxsb3cgb3ZlcnJpZGUuXG4gICAgLy8gVE9ETzogU2VlIGlmIGZsZXggb3JkZXIgaXMgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUgdG8gcG9zaXRpb24gYXJyb3cgdG9wIG9yIGJvdHRvbS5cbiAgICB0aGlzLnBvcG92ZXJBcnJvd1N0eWxlcyA9IHtcbiAgICAgICdyaWdodCc6IHRoaXMucG9zaXRpb25YID09PSAnYmVmb3JlJyA/ICh0aGlzLmFycm93T2Zmc2V0WCAtIHRoaXMuYXJyb3dXaWR0aCkgKyAncHgnIDogJycsXG4gICAgICAnbGVmdCc6IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcbiAgICAgICdib3JkZXItdG9wJzogdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycgP1xuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6ICcwcHggc29saWQgdHJhbnNwYXJlbnQnLFxuICAgICAgJ2JvcmRlci1yaWdodCc6ICd1bmRlZmluZWQnID09PSB1bmRlZmluZWQgP1xuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXG4gICAgICAnYm9yZGVyLWJvdHRvbSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnID9cbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxuICAgICAgJ2JvcmRlci1sZWZ0JzogJ3VuZGVmaW5lZCcgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogUmVtb3ZlIGlmIGZsZXggb3JkZXIgaXMgYWRkZWQuXG4gICAgdGhpcy5wb3BvdmVyQ29udGVudFN0eWxlcyA9IHtcbiAgICAgICdwYWRkaW5nLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgPyAnMHB4JyA6IHRoaXMuYXJyb3dXaWR0aCArICdweCcsXG4gICAgICAncGFkZGluZy1ib3R0b20nOiB0aGlzLm92ZXJsYXBUcmlnZ2VyID09PSB0cnVlID8gJzBweCcgOiAodGhpcy5hcnJvd1dpZHRoKSArICdweCcsXG4gICAgICAnbWFyZ2luLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlICYmIHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnICYmIHRoaXMuY29udGFpbmVyUG9zaXRpb25pbmcgPT09IGZhbHNlID9cbiAgICAgICAgLSh0aGlzLmFycm93V2lkdGggKiAyKSArICdweCcgOiAnMHB4J1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSXQncyBuZWNlc3NhcnkgdG8gc2V0IHBvc2l0aW9uLWJhc2VkIGNsYXNzZXMgdG8gZW5zdXJlIHRoZSBwb3BvdmVyIHBhbmVsIGFuaW1hdGlvblxuICAgKiBmb2xkcyBvdXQgZnJvbSB0aGUgY29ycmVjdCBkaXJlY3Rpb24uXG4gICAqL1xuICBzZXRQb3NpdGlvbkNsYXNzZXMocG9zWCA9IHRoaXMucG9zaXRpb25YLCBwb3NZID0gdGhpcy5wb3NpdGlvblkpOiB2b2lkIHtcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWJlZm9yZSddID0gcG9zWCA9PT0gJ2JlZm9yZSc7XG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1hZnRlciddID0gcG9zWCA9PT0gJ2FmdGVyJztcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFib3ZlJ10gPSBwb3NZID09PSAnYWJvdmUnO1xuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVsb3cnXSA9IHBvc1kgPT09ICdiZWxvdyc7XG4gIH1cbn1cbiJdfQ==