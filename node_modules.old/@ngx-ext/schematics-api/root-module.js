"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootModule = void 0;
var ast_utils_1 = require("@schematics/angular/utility/ast-utils");
var change_1 = require("@schematics/angular/utility/change");
var functions_1 = require("./functions");
var schematics_api_exception_1 = require("./schematics-api-exception");
var core_1 = require("@angular-devkit/core");
var RootModule = /** @class */ (function () {
    function RootModule(tree) {
        this.allChanges = [];
        this.tree = tree;
        this.path = core_1.normalize('./' + functions_1.getDefaultProjectRootModulePath(this.tree));
        this.source = functions_1.getSourceFile(this.tree, this.path);
    }
    RootModule.getInstance = function (tree) {
        if (!this._instance) {
            this._instance = new RootModule(tree);
        }
        return this._instance;
    };
    RootModule.prototype.setDefaultImportPath = function (path) {
        this.importPath = core_1.normalize(path);
    };
    RootModule.prototype.getDefaultImportPath = function () {
        return this.importPath;
    };
    RootModule.prototype.getAllChanges = function () {
        return this.allChanges;
    };
    /**
     * Allows to overwrite the changes
     * @example leaving only insertions:
     * const root = RootModule.getInstance(tree, '@my/lib');
     * root.addExport(...); root.addImport(...); etc
     * root.setAllChanges(root.getAllChanges()
     *      .filter(change => change instanceof InsertChange));
     * root.applyAllChanges();
     */
    RootModule.prototype.setAllChanges = function (allChanges) {
        this.allChanges = allChanges;
    };
    RootModule.prototype.applyAllChanges = function () {
        var recorder = this.tree.beginUpdate(this.path);
        change_1.applyToUpdateRecorder(recorder, this.allChanges);
        this.tree.commitUpdate(recorder);
        return this.tree;
    };
    /**
     * Clears list of changes, doesn't revert them if already applied
     */
    RootModule.prototype.discardAllChanges = function () {
        this.allChanges = [];
    };
    /**
     * Add Import statement (`import { symbolName } from fileName`) if the import doesn't exist already.
     * @param symbolName (item to import)
     * @param fileName (path to the file)
     * @param isDefault (if true, import follows style for importing default exports)
     * @return Change
     */
    RootModule.prototype.insertImport = function (symbolName, fileName, isDefault) {
        var change = ast_utils_1.insertImport(this.source, this.path, symbolName, fileName, isDefault);
        this.allChanges.push(change);
        return change;
    };
    /**
     * Custom function to insert a declaration (component, pipe, directive)
     * into NgModule declarations. It also imports the component.
     */
    RootModule.prototype.addDeclaration = function (classifiedName, importPath) {
        var changes = ast_utils_1.addDeclarationToModule(this.source, this.path, classifiedName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    /**
     * Custom function to insert an NgModule into NgModule imports. It also imports the module.
     */
    RootModule.prototype.addImport = function (classifiedName, importPath) {
        var changes = ast_utils_1.addImportToModule(this.source, this.path, classifiedName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    /**
     * Custom function to insert a provider into NgModule. It also imports it.
     */
    RootModule.prototype.addProvider = function (classifiedName, importPath) {
        var changes = ast_utils_1.addProviderToModule(this.source, this.path, classifiedName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    /**
     * Custom function to insert an export into NgModule. It also imports it.
     */
    RootModule.prototype.addExport = function (classifiedName, importPath) {
        var changes = ast_utils_1.addExportToModule(this.source, this.path, classifiedName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    /**
     * Custom function to insert an export into NgModule. It also imports it.
     */
    RootModule.prototype.addBootstrap = function (classifiedName, importPath) {
        var changes = ast_utils_1.addBootstrapToModule(this.source, this.path, classifiedName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    /**
     * Custom function to insert an entryComponent into NgModule. It also imports it.
     * @deprecated - Since Angular 9.0.0 with Ivy, entryComponents is no longer necessary.
     */
    RootModule.prototype.addEntryComponent = function (classifiedName, importPath) {
        var changes = ast_utils_1.addEntryComponentToModule(this.source, this.path, classifiedName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    /**
     * Determine if an import already exists.
     */
    RootModule.prototype.isImported = function (classifiedName, importPath) {
        return ast_utils_1.isImported(this.source, classifiedName, this.getImportPath(importPath));
    };
    /**
     * Returns the RouterModule declaration from NgModule metadata, if any.
     */
    RootModule.prototype.getRouterModuleDeclaration = function () {
        return ast_utils_1.getRouterModuleDeclaration(this.source);
    };
    /**
     * Adds a new route declaration to a router module (i.e. has a RouterModule declaration)
     */
    RootModule.prototype.addRouteDeclarationToModule = function (fileToAdd, routeLiteral) {
        var change = ast_utils_1.addRouteDeclarationToModule(this.source, fileToAdd, routeLiteral);
        this.allChanges.push(change);
        return change;
    };
    RootModule.prototype.getDecoratorMetadata = function (metadataField, symbolName, importPath) {
        var changes = ast_utils_1.addSymbolToNgModuleMetadata(this.source, this.path, metadataField, symbolName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    RootModule.prototype.addSymbolToNgModuleMetadata = function (metadataField, symbolName, importPath) {
        var changes = ast_utils_1.addSymbolToNgModuleMetadata(this.source, this.path, metadataField, symbolName, this.getImportPath(importPath));
        this.allChanges = this.allChanges.concat(changes);
        return changes;
    };
    RootModule.prototype.getImportPath = function (path) {
        if (typeof path === 'string') {
            return core_1.normalize(path);
        }
        if (!this.importPath) {
            throw new schematics_api_exception_1.SchematicsApiException('No import path was provided.');
        }
        return this.importPath;
    };
    return RootModule;
}());
exports.RootModule = RootModule;
